{% extends 'base.html' %}
{% block content %}
<div style="background-color:#c4e3f3;margin-left: 10%;margin-right: 10%;border-radius: 3%" >
  <h1 align="center">J中Java常用的输入输出小结</h1>
    <br>
  <p>技术杂谈于 2011 年 3 月 14 日发布</p>
    <div class="post-meta clearfix">
										<span class="date">25 Feb, 2013</span>
										<span class="category"><a href="#" title="View all posts in Server &amp; Database">Server &amp; Database</a></span>
										<span class="comments"><a href="#" title="Comment on Integrating WordPress with Your Website">3 Comments</a></span>
										<span class="like-count">66</span>
									</div>
  <pre style="word-break:break-word;">
&nbsp;&nbsp;&nbsp;&nbsp; <p>基于Java11的测试,由于电脑性能的差异，测试使用的是jdk自带的javac/java编译和运行，但是由于磁盘的IO操作比较费时，数据不准确，参考了网上的测试结果，新手整理错误难免，希望大家多多指教 `` <br />
（一）java.io.BufferedReader</p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception {
        char c ;
        BufferedReader bd = new BufferedReader(new InputStreamReader(System.in));
        //read()，读入一个字符
        System.out.println(&quot;input char,end with 'e'&quot;);
        do {
            c = (char)bd.read() ;
            System.out.println(c);
        }while(c != 'e') ;
        //readLine(),读入每行的文本数据(包括空格)
        String str=null ;
        System.out.println(&quot;string end with 'end'&quot;);
        do {
            str = bd.readLine() ;
            System.out.println(str);
        }while(!str.equals(&quot;end&quot;)) ;
    }
}
</code></pre>

<p>(二)java.util.Scanner<br />
利用Scanner类进行输入之前最好使用hasNextXXX（）验证一下，在使用next()读入数据。Scanner最常用，正常情况下都是是够用；不过当输入量和输出量太大的时候（达到百万到千万），那么这种输出方式就不够用了</p>
<pre><code>Scanner scan = new Scanner(System.in) ;
        if(scan.hasNext()) {
            System.out.println(scan.next());//读取到有效的字符才结束，有效字符前的空白被自动去掉，有效字符后的空白被当作结束符，因此next()不能读取有空格的字符串
        }
        if(scan.hasNext()) {
            System.out.println(scan.nextLine());//与BufferdeReader的readLine()类似，读入一行字符串以回车结束
        }
</code></pre>

<p>Scanner类不仅支持输入字符串，还支持基本数据类型的输入。</p>
<pre><code>Scanner scan = new Scanner(System.in) ;
        int a=0,b=0 ;
        if(scan.hasNextInt()) {//double,boolean,byte…类似
            a = scan.nextInt() ;
            b = scan.nextInt() ;
        }
        System.out.println(a+b);
        scan.close();
</code></pre>

<p>//输入n组数据的格式</p>
<pre><code>Scanner scan = new Scanner(System.in) ;
        int a,b ;
        int n = scan.nextInt() ;
        for(int i=0;i&lt;n;i++) {
            a = scan.nextInt() ;
            b = scan.nextInt() ;
        }
        scan.close();
</code></pre>

<p>(三)java.io.StreamTokenizer（读取数据最快的类）<br />
用该类读取数据时只能读取由字母或数字组成的字符串，如果含有特殊符号，特殊符号占据一个令牌，并且返回null或者0，这是StreamTokenizer的缺点（该类居然还支持中文文本，hh），该类的读取规则为空白为分割符。可以利用该类对大文本进行符号，数字，字母进行快速统计</p>
<pre><code>StreamTokenizer st = new StreamTokenizer(new BufferedReader
                (new InputStreamReader(System.in))) ;
        st.nextToken() ;//获得令牌
        String str = st.sval ;//取出令牌，sval为该类的静态常量
        //表示一个文本，以制表符，换行符，空格为分割符
        st.nextToken() ;
        int a = (int) st.nval ;//nval为该类的静态常量，表示读取的是个数字
        System.out.println(str);
        System.out.println(a);
</code></pre>

<p>(四)java.util.StringTokenizer类<br />
令牌类的特点时读取数据的速度快，其底层采用的是字符分割的原理</p>
<pre><code>StringTokenizer st = new StringTokenizer(&quot;this is in china&quot;) ;//默认是空格为分割符
        while(st.hasMoreTokens()) {
            System.out.println(st.nextToken());
        }
        StringTokenizer st1 = new StringTokenizer(&quot;this is my ida,and this is also yours&quot;,&quot; ,&quot;) ;   //自定义分割符
    while(st1.hasMoreTokens()) {
            System.out.println(st1.nextToken());
        }
</code></pre>

<p>(五)控制台输出<br />
a.java.io.PrintWriter</p>
<pre><code>public class Test {（2306ms）
    public static void main(String[] args) throws Exception {
        PrintWriter pw = new PrintWriter(System.out) ;
        long start = System.currentTimeMillis();
        for(int i=0;i&lt;1000000;i++) {
            pw.println(i) ;
        }
        long end = System.currentTimeMillis() ;
        pw.flush();
        Thread.sleep(10000);
        System.out.println(&quot;时间：&quot;+(end-start));
        pw.close();
    }
}
</code></pre>

<p>b.System.out.println方法</p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception {
        long start = System.currentTimeMillis();
        for(int i=0;i&lt;1000000;i++) {
            System.out.println(i);
        }
        long end = System.currentTimeMillis() ;
        System.out.println(&quot;时间：&quot;+(end-start));
    }
}
</code></pre>

<p>(六)测试<br />
“in.txt”文件为1000000行的数字构成<br />
a.  Scanner(2930ms)</p>
<pre><code>public class Test {
    public static void main(String[] args) throws Exception{
        Scanner scan = new Scanner(System.in) ;
        long start = System.currentTimeMillis();
        String str = null ;
        for(int i=0;i&lt;2000000;i++){
            if(scan.hasNext()){
                scan.next() ;
            }
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;time=&quot;+(end-start)+&quot;ms&quot;);
    }
}
</code></pre>

此篇为转载博客，原文：https://www.acwing.com/blog/content/279/


								</pre>
</div>
{% endblock %}